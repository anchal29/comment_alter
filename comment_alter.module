<?php
/**
* @file
* Allows to alter entities from comment form.
*/

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\Core\Render\Element;
use Drupal\Core\Form\FormState;

/**
 * Implements hook_form_FORM_ID_alter().
 */
function comment_alter_form_field_config_edit_form_alter(&$form, FormStateInterface $form_state) {
  $field = $form_state->getFormObject()->getEntity();

  // To ensure that comment alter fields of parent entity is not present in the
  // comment form. This case only arise if parent entity is comment itself so,
  // removing that option.
  if ($field->getTargetEntityTypeId() == 'comment') {
    return;
  }
  $form['third_party_settings']['comment_alter']['comment_alter_enabled'] = [
    '#type' => 'checkbox',
    '#title' => t('User may alter this field from comment.'),
    '#weight' => 0,
    '#default_value' => $field->getThirdPartySetting('comment_alter', 'comment_alter_enabled', FALSE),
    '#description' => t('This allows user to alter this field from comment attached to the parent entity'),
  ];
  $form['third_party_settings']['comment_alter']['comment_alter_hide'] = [
    '#type' => 'checkbox',
    '#title' => t('Hide alterations of this field from diffs.'),
    '#weight' => 1,
    '#default_value' => $field->getThirdPartySetting('comment_alter', 'comment_alter_hide', FALSE),
    '#states' => [
      'invisible' => [':input[name="third_party_settings[comment_alter][comment_alter_enabled]"]' => ['checked' => FALSE]],
    ],
  ];
  $form['third_party_settings']['#weight'] = $form['required']['#weight'] + 0.7;

  // @TODO
  // Move these three options to parent entity edit form.
  $entity_type = explode('.', $field->getOriginalId());
  if ($entity_type[0] == 'comment') {
    $form['third_party_settings']['comment_alter']['comment_alter_default'] = [
      '#type' => 'checkbox',
      '#title' => t('Use the latest revision as the default values for comment alterable fields (if any)'),
      '#weight' => 2,
      '#default_value' => $field->getThirdPartySetting('comment_alter', 'comment_alter_default', FALSE),
      '#description' => t('Loads the field values from the latest revision of the node (instead of the current revision) when the comment form is displayed.'),
    ];
    $form['third_party_settings']['comment_alter']['comment_alter_diff_link'] = [
      '#type' => 'checkbox',
      '#title' => t('Add a link to the usual diff of the two revisions to the links area of the comment'),
      '#weight' => 3,
      '#default_value' => $field->getThirdPartySetting('comment_alter', 'comment_alter_diff_link', FALSE),
    ];
    $form['third_party_settings']['comment_alter']['comment_alter_reply'] = [
      '#type' => 'checkbox',
      '#title' => t('Allow altering fields when submitting reply comments'),
      '#weight' => 4,
      '#default_value' => $field->getThirdPartySetting('comment_alter', 'comment_alter_root_only', FALSE),
    ];
  }

  // Clearing cache to ensure that cache is removed if we select comment alter
  // option for a field.
  \Drupal::cache()->delete('comment_alter_fields:' . $entity_type[0] . ':' . $entity_type[1]);

}

/**
 * Returns the comment alterable fields for an entity.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Entity object for the parent entity.
 *
 * @return array
 *   An array of comment alterable fields on parent entity.
 */
function comment_alter_get_alterable_fields($entity_type, $bundle) {
  $cid = 'comment_alter_fields:' . $entity_type . ':' . $bundle;
  $comment_alter_fields = &drupal_static(__FUNCTION__);
  if (!isset($comment_alter_fields[$entity_type][$bundle])) {
    if ($cache = \Drupal::cache()->get($cid)) {
      $comment_alter_fields[$entity_type][$bundle] = $cache->data;
    }
    else {
      $field_definitions = \Drupal::entityManager()->getFieldDefinitions($entity_type, $bundle);
      foreach ($field_definitions as $field_name => $field_item) {
        // Check if we are dealing with an actual field. The
        // getThirdPartySetting method is available only for an actual field.
        if (is_a($field_item, 'Drupal\field\Entity\FieldConfig') && $field_item->getThirdPartySetting('comment_alter', 'comment_alter_enabled', FALSE)) {
          $comment_alter_fields[$entity_type][$bundle][$field_name] = $field_name;
        }
      }
      \Drupal::cache()->set($cid, $comment_alter_fields[$entity_type][$bundle]);
    }
  }

  return $comment_alter_fields[$entity_type][$bundle];
}


/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function comment_alter_form_comment_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $comment_entity = $form_state->getFormObject()->getEntity();
  if (!$comment_entity->isNew()) {
      return;
  }
  elseif ($comment_entity->hasParentComment()) {
    // @todo Check if user has selected this option or not.
    return;
  }
  else {
    $parent_entity = $comment_entity->getCommentedEntity();
    $comment_alterable_fields = comment_alter_get_alterable_fields($parent_entity->getEntityTypeId(), $parent_entity->bundle());
    if (empty($comment_alterable_fields)) {
      return;
    }
    // The _comment_alter_submit_node_fields() function needs these two arrays.
    // This one is a list of comment_alterable fields.
    $alterable_fields = [];
    // It turns out that we don't need to retrieve pseudo field's weight as
    // here Drupal assigns the weight of pseudo fields automatically. So,
    // we may reorder the pseudo fields and Drupal will take care of the
    // position of its widget. Hence, we are not assigning the weight property
    // to the field widgets that are created here.
    $parent_form_display = entity_get_form_display($parent_entity->getEntityTypeId(), $parent_entity->bundle(), 'default');
    // Attach parent entity fields to the comment form. Do it on a copy of the
    // $form, so that we know we are only getting the field element itself and
    // no other side-effects.
    $parent_form = $form;
    $parent_form_state = new FormState();
    $parent_form_display->buildForm($parent_entity, $parent_form, $parent_form_state);
    foreach ($comment_alterable_fields as $alterable_field_name) {
      if (empty($parent_form[$alterable_field_name])) {
        continue;
      }
      $form[$alterable_field_name] = $parent_form[$alterable_field_name];
      // Remember that this field is alterable.
      $alterable_fields[$alterable_field_name] = $alterable_field_name;
    }

    if (!empty($alterable_fields)) {
      $form['comment_alter'] = [
        '#type' => 'value',
        '#value' => [
          'fields' => $alterable_fields,
          'old_vid' => $parent_entity->getRevisionId(),
        ],
      ];
      // Adding our own afterBuild call to this form, so we could add the
      // column information into the $form itself.
      $form['#after_build'][] = 'comment_alter_form_comment_form_alter_after_build';
      $form['#validate'][] = 'comment_alter_form_comment_form_alter_validate';
      $form['actions']['submit']['#submit'][] = 'comment_alter_form_comment_form_alter_submit';
    }
  }
}

/**
 * Custom #after_build callback for comment_form to add comment alterable
 * columns info and values.
 */
function comment_alter_form_comment_form_alter_after_build(&$form, FormStateInterface $form_state) {
  $parent_entity = $form_state->getFormObject()->getEntity()->getCommentedEntity();
  // This one informs about comment_alterable columns per comment_alterable
  // fields. First-level key is the field name, second-level keys (and values)
  // are the columns which do have their form elements.
  $alterable_columns = [];
  // It stores the old/current column value for all the comment
  // alterable fields.
  $field_value = [];
  foreach ($form['comment_alter']['#value']['fields'] as $alterable_field) {
    $field_items = Element::children($form[$alterable_field]['widget']);
    // Get the column info from first level if it is available there else get
    // it from the first item. In case it is available at the first level then
    // field_items should be string there.
    $columns = (is_string($field_items['0'])) ? $field_items : Element::children($form[$alterable_field]['widget']['0']);
    foreach ($columns as $column) {
      $alterable_columns[$alterable_field][$column] = $column;
    }
    $field_value[$alterable_field] = $parent_entity->$alterable_field->getValue();
    // Store the old/current column value for this alterable field.
    $form['comment_alter_' . $alterable_field . '_old'] = [
      '#type' => 'value',
      '#value' => $field_value[$alterable_field],
    ];
  }
  $form['alterable_columns'] = [
    '#type' => 'value',
    '#value' => $alterable_columns,
  ];

  return $form;
}

/**
 * Validation callback for the altered comment form.
 */
function comment_alter_form_comment_form_alter_validate($form, FormStateInterface &$form_state) {
  // @todo Check the vaidation callback function.
  $parent_entity = $form_state->getFormObject()->getEntity()->getCommentedEntity();
  $parent_form_display = entity_get_form_display($parent_entity->getEntityTypeId(), $parent_entity->bundle(), 'default');
  // $parent_form_display->validateFormValues($parent_entity, $form, $form_state);

}

/**
 * Submit callback for the altered comment form.
 */
function comment_alter_form_comment_form_alter_submit($form, FormStateInterface &$form_state) {
  // @todo Check if there was actually some change in the alterable fields
  // If there weren't any changes then return.
  $values = $form_state->getValues();
  $parent_entity = $form_state->getFormObject()->getEntity()->getCommentedEntity();
  $parent_form_display = entity_get_form_display($parent_entity->getEntityTypeId(), $parent_entity->bundle(), 'default');
  $parent_form = $form;
  $parent_form_state = new FormState();
  $parent_form_display->buildForm($parent_entity, $parent_form, $parent_form_state);
  foreach ($values['comment_alter']['fields'] as $alterable_field) {
    $parent_form_state->setValue($alterable_field, $values[$alterable_field]);
  }
  $parent_form_display->extractFormValues($parent_entity, $parent_form, $parent_form_state);
  $parent_entity->save();
  drupal_set_message('Succesfully updated the alterable fields of parent entity');

}


/**
 * Implements hook_form_alter().
 */
function comment_alter_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  return;
  // @todo Find suitable form alter.

}

/**
 * Implements hook_entity_extra_field_info().
 */
function comment_alter_entity_extra_field_info() {
  $extra = [];
  $comment_bundles = [];
  foreach (\Drupal::entityManager()->getDefinitions() as $entity_type => $entity_definition) {
    // Handle only non-comment content entity types.
    if (!$entity_definition instanceof Drupal\Core\Entity\ContentEntityTypeInterface || $entity_type == 'comment') {
      continue;
    }
    // Store the comment type or the comment bundle using FieldStorageDefinition
    // associated with this entity type, which can be accessed for any of its
    // bundle using the field machine name.
    $field_storage_definitions = \Drupal::entityManager()->getFieldStorageDefinitions($entity_type);
    foreach ($field_storage_definitions as $field_name => $field_storage_definition) {
      if (!$field_storage_definition instanceof Drupal\Core\Field\BaseFieldDefinition && $field_storage_definition->getType() == 'comment') {
        $comment_bundles[$entity_type][$field_name] = $field_storage_definition->getSetting('comment_type');
        $weight[$comment_bundles[$entity_type][$field_name]] = 0;
      }
    }
    // No need to further processing if there are no comment fields on this
    // content entity bundle.
    if (empty($comment_bundles[$entity_type])) {
      continue;
    }
    foreach (entity_get_bundles($entity_type) as $bundle => $bundle_info) {
      // Retrieve the list of comment_alterable_fields for this entity_type's
      // current bundle.
      $comment_alterable_fields = comment_alter_get_alterable_fields($entity_type, $bundle);
      // Skip to the next bundle if there are no comment_alterable_fields.
      if (empty($comment_alterable_fields)) {
        continue;
      }
      // If this content entity type and bundle has any comment_alterable
      // field, then _ALL_ the comment types (bundles) should have the extra
      // field info on them (about _ALL_ these comment_alterable fields). But:
      // only those comment types (bundles) should have this info, which are
      // attached to this content entity type and bundle.
      // To retrieve the list of comment types (bundles) attached to this
      // entity type and bundle, we'll use the above created comment_bundles
      // array. So, we need to store all the comment fields for this entity type
      // and bundle in order to get comment bundle for the corresponding field.
      $comment_fields = [];
      $field_definitions = \Drupal::entityManager()->getFieldDefinitions($entity_type, $bundle);
      foreach ($field_definitions as $field_name => $field_definition) {
        if ($field_definition->getType() == 'comment') {
          $comment_fields[] = $field_name;
        }
      }

      // Now that we have all the info needed, let's build the extra field
      // info array.
      foreach ($comment_fields as $comment_field) {
        foreach ($comment_alterable_fields as $field_name) {
          $field = FieldConfig::loadByName($entity_type, $bundle, $field_name);
          $extra['comment'][$comment_bundles[$entity_type][$comment_field]]['form'][$field_name] = [
            'label' => $field->getLabel(),
            'description' => $field->getDescription(),
            'weight' => $weight[$comment_bundles[$entity_type][$comment_field]],
          ];
          $weight[$comment_bundles[$entity_type][$comment_field]]++;
        }
        $extra['comment'][$comment_bundles[$entity_type][$comment_field]]['display']['comment_alter'] = [
          'label' => t('Comment changes'),
          'description' => t('Changes made to the parent node\'s fields in this comment.'),
          'weight' => -1,
        ];
      }
    }
  }

  return $extra;
}
